<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-interview/interview-redis">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Redis 篇 | 与你同行-黑铁教程</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://47.113.86.188:12321/docs/interview/interview-redis"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Redis 篇 | 与你同行-黑铁教程"><meta data-rh="true" name="description" content="Redis 与 Memcache 的区别？"><meta data-rh="true" property="og:description" content="Redis 与 Memcache 的区别？"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="http://47.113.86.188:12321/docs/interview/interview-redis"><link data-rh="true" rel="alternate" href="http://47.113.86.188:12321/docs/interview/interview-redis" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="http://47.113.86.188:12321/docs/interview/interview-redis" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="与你同行-黑铁教程 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="与你同行-黑铁教程 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.39c269dc.css">
<link rel="preload" href="/assets/js/runtime~main.1bbccddd.js" as="script">
<link rel="preload" href="/assets/js/main.ce06d064.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="黑铁教程 Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="黑铁教程 Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">与你同行-黑铁教程</b></a><a class="navbar__item navbar__link" href="/docs/java">Java</a><a class="navbar__item navbar__link" href="/docs/category/常见面试题">面试宝典</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/blog">博客</a><a href="https://github.com/yntx-it" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/常见面试题">常见面试题</a><button aria-label="打开/收起侧边栏菜单「常见面试题」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-algorithm">算法篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-design">设计模式篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-base">基础篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-collection">集合篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-concurrency">并发篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-jvm">JVM 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-microservice">微服务篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-mysql">MySQL 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/interview/interview-redis">Redis 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-mq">MQ 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-spring">Spring 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-mybatis">MyBatis 的原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/interview-other">补充篇</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/常见面试题"><span itemprop="name">常见面试题</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Redis 篇</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>Redis 篇</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-与-memcache-的区别">Redis 与 Memcache 的区别？<a class="hash-link" href="#redis-与-memcache-的区别" title="标题的直接链接">​</a></h2><ul><li><code>redis支持更丰富的数据类型</code>（支持更复杂的应用场景）：Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。</li><li><code>Redis支持数据的持久化</code>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</li><li><code>集群模式</code>：memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><code>Redis使用单线程</code>：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-的单线程为什么那么快">Redis 的单线程为什么那么快<a class="hash-link" href="#redis-的单线程为什么那么快" title="标题的直接链接">​</a></h2><p><strong>面试官</strong>：Redis 采用单线程，如何保证高并发？</p><p><strong>面试话术</strong>：</p><p>Redis 快的主要原因是：</p><ol><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I/O 复用模型，充分利用 CPU 资源</li><li>单线程的好处是不用考虑并发加锁问题，不会出现加锁和释放锁导致性能下降</li></ol><p><strong>面试官</strong>：这样做的好处是什么？</p><p><strong>面试话术</strong>：</p><p>单线程优势有下面几点：</p><ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的 CPU 切换，充分利用 CPU 资源</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-的持久化方案由哪些">Redis 的持久化方案由哪些？<a class="hash-link" href="#redis-的持久化方案由哪些" title="标题的直接链接">​</a></h2><p><strong>相关资料：</strong></p><p>1）RDB 持久化</p><p>RDB 持久化可以使用 save 或 bgsave，为了不阻塞主进程业务，一般都使用 bgsave，流程：</p><ul><li>Redis 进程会 fork 出一个子进程（与父进程内存数据一致）。</li><li>父进程继续处理客户端请求命令</li><li>由子进程将内存中的所有数据写入到一个临时的 RDB 文件中。</li><li>完成写入操作之后，旧的 RDB 文件会被新的 RDB 文件替换掉。</li></ul><p>下面是一些和 RDB 持久化相关的配置：</p><ul><li><code>save 60 10000</code>：如果在 60 秒内有 10000 个 key 发生改变，那就执行 RDB 持久化。</li><li><code>stop-writes-on-bgsave-error yes</code>：如果 Redis 执行 RDB 持久化失败（常见于操作系统内存不足），那么 Redis 将不再接受 client 写入数据的请求。</li><li><code>rdbcompression yes</code>：当生成 RDB 文件时，同时进行压缩。</li><li><code>dbfilename dump.rdb</code>：将 RDB 文件命名为 dump.rdb。</li><li><code>dir /var/lib/redis</code>：将 RDB 文件保存在<code>/var/lib/redis</code>目录下。</li></ul><p>当然在实践中，我们通常会将<code>stop-writes-on-bgsave-error</code>设置为<code>false</code>，同时让监控系统在 Redis 执行 RDB 持久化失败时发送告警，以便人工介入解决，而不是粗暴地拒绝 client 的写入请求。</p><p>RDB 持久化的优点：</p><ul><li>RDB 持久化文件小，Redis 数据恢复时速度快</li><li>子进程不影响父进程，父进程可以持续处理客户端命令</li><li>子进程 fork 时采用 copy-on-write 方式，大多数情况下，没有太多的内存消耗，效率比较好。</li></ul><p>RDB 持久化的缺点：</p><ul><li>子进程 fork 时采用 copy-on-write 方式，如果 Redis 此时写操作较多，可能导致额外的内存占用，甚至内存溢出</li><li>RDB 文件压缩会减小文件体积，但通过时会对 CPU 有额外的消耗</li><li>如果业务场景很看重数据的持久性 (durability)，那么不应该采用 RDB 持久化。譬如说，如果 Redis 每 5 分钟执行一次 RDB 持久化，要是 Redis 意外奔溃了，那么最多会丢失 5 分钟的数据。</li></ul><p>2）AOF 持久化</p><p>可以使用<code>appendonly yes</code>配置项来开启 AOF 持久化。Redis 执行 AOF 持久化时，会将接收到的写命令追加到 AOF 文件的末尾，因此 Redis 只要对 AOF 文件中的命令进行回放，就可以将数据库还原到原先的状态。
　　与 RDB 持久化相比，AOF 持久化的一个明显优势就是，它可以提高数据的持久性 (durability)。因为在 AOF 模式下，Redis 每次接收到 client 的写命令，就会将命令<code>write()</code>到 AOF 文件末尾。
　　然而，在 Linux 中，将数据<code>write()</code>到文件后，数据并不会立即刷新到磁盘，而会先暂存在 OS 的文件系统缓冲区。在合适的时机，OS 才会将缓冲区的数据刷新到磁盘（如果需要将文件内容刷新到磁盘，可以调用<code>fsync()</code>或<code>fdatasync()</code>）。
　　通过<code>appendfsync</code>配置项，可以控制 Redis 将命令同步到磁盘的频率：</p><ul><li><code>always</code>：每次 Redis 将命令<code>write()</code>到 AOF 文件时，都会调用<code>fsync()</code>，将命令刷新到磁盘。这可以保证最好的数据持久性，但却会给系统带来极大的开销。</li><li><code>no</code>：Redis 只将命令<code>write()</code>到 AOF 文件。这会让 OS 决定何时将命令刷新到磁盘。</li><li><code>everysec</code>：除了将命令<code>write()</code>到 AOF 文件，Redis 还会每秒执行一次<code>fsync()</code>。在实践中，推荐使用这种设置，一定程度上可以保证数据持久性，又不会明显降低 Redis 性能。</li></ul><p>然而，AOF 持久化并不是没有缺点的：Redis 会不断将接收到的写命令追加到 AOF 文件中，导致 AOF 文件越来越大。过大的 AOF 文件会消耗磁盘空间，并且导致 Redis 重启时更加缓慢。为了解决这个问题，在适当情况下，Redis 会对 AOF 文件进行重写，去除文件中冗余的命令，以减小 AOF 文件的体积。在重写 AOF 文件期间， Redis 会启动一个子进程，由子进程负责对 AOF 文件进行重写。
　　可以通过下面两个配置项，控制 Redis 重写 AOF 文件的频率：</p><ul><li><code>auto-aof-rewrite-min-size 64mb</code></li><li><code>auto-aof-rewrite-percentage 100</code></li></ul><p>上面两个配置的作用：当 AOF 文件的体积大于 64MB，并且 AOF 文件的体积比上一次重写之后的体积大了至少一倍，那么 Redis 就会执行 AOF 重写。</p><p>优点：</p><ul><li>持久化频率高，数据可靠性高</li><li>没有额外的内存或 CPU 消耗</li></ul><p>缺点：</p><ul><li>文件体积大</li><li>文件大导致服务数据恢复时效率较低</li></ul><p><strong>面试话术：</strong></p><p>Redis 提供了两种数据持久化的方式，一种是 RDB，另一种是 AOF。默认情况下，Redis 使用的是 RDB 持久化。</p><p>RDB 持久化文件体积较小，但是保存数据的频率一般较低，可靠性差，容易丢失数据。另外 RDB 写数据时会采用 Fork 函数拷贝主进程，可能有额外的内存消耗，文件压缩也会有额外的 CPU 消耗。</p><p>ROF 持久化可以做到每秒钟持久化一次，可靠性高。但是持久化文件体积较大，导致数据恢复时读取文件时间较长，效率略低</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-的集群方式有哪些">Redis 的集群方式有哪些？<a class="hash-link" href="#redis-的集群方式有哪些" title="标题的直接链接">​</a></h2><p><strong>面试话术：</strong></p><p>Redis 集群可以分为<strong>主从集群</strong>和<strong>分片集群</strong>两类。</p><p><strong>主从集群</strong>一般一主多从，主库用来写数据，从库用来读数据。结合哨兵，可以在主库宕机时重新选主，<strong>目的是保证 Redis 的高可用</strong>。</p><p><strong>分片集群</strong>是数据分片，我们会让多个 Redis 节点组成集群，并将 16384 个插槽分到不同的节点上。存储数据时利用对 key 做 hash 运算，得到插槽值后存储到对应的节点即可。因为存储数据面向的是插槽而非节点本身，因此可以做到集群动态伸缩。<strong>目的是让 Redis 能存储更多数据。</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-主从集群">1. 主从集群<a class="hash-link" href="#1-主从集群" title="标题的直接链接">​</a></h3><p>主从集群，也是读写分离集群。一般都是一主多从方式。</p><p><code>主从复制</code>：2.8 版本后是基于==PSYNC==命令来实现的，分为==完整重同步==和==部分重同步==。</p><ul><li>==完整重同步==：用来处理初次复制的情况，通过发送 RDB 文件和缓冲区里的写命令来同步。</li><li>==部分重同步==：用来处理断线后重复制的情况，只发送断线期间的写命令来同步。</li></ul><p>部分重同步的实现原理：</p><ul><li><p>==主、从服务器的复制偏移量==：主服务器每次传播 N 个字节，+N。从服务每次接受 N 个字节，+N。</p></li><li><p>==主服务器的复制积压缓冲区==：定长的 FIFO 队列，默认 1MB。每个字节记录对应的复制偏移量。断线重连时，如果偏移量还在复制及压缓冲区，说明可以执行部分重同步。否则，执行完整重同步。</p></li><li><p>==服务器运行 ID（run ID）==：从服务器会保存复制的主服务器的运行 ID，断线后重连时，如果主服务器 ID 相同，说明可以继续执行部分重同步。否则，执行完整重同步。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-sentinel-集群">2. Sentinel 集群<a class="hash-link" href="#2-sentinel-集群" title="标题的直接链接">​</a></h3><p>哨兵集群加 Redis 主从集群组成，当监视到主服务器宕机时，自动下线主服务器，并且择优选取从服务器作为主服务器。</p><p>Sentinel 服务器本质上是一个特殊模式的 redis 服务器，不会用到数据库，不需要载入 RDB 和 AOF 文件。</p><p><code>作用</code>：监控、故障转移和通知。</p><p><code>监控过程</code>：</p><ol><li>每秒一次向所有服务器发送==PING==指令，根据返回==+PONG==、==-LOADING==和==-MASTERDOWN==判断是否在线，否则为主观下线。</li><li>超过==quorum==参数 Sentinel 都认为主观下线，则判断服务已下线，进入故障转移。</li></ol><p><code>故障转移前</code>，首先要选举领头 Sentinel：</p><ol><li>每个 Sentinel 都有机会，谁先发送==Sentinel is-master-down-by-addr==命令，谁先获得一票。</li><li>被超过==半数==以上的 Sentinel 设置成了==局部领头 Sentinel==则成为==领头 Sentinel==。</li><li>如果给定时间内没有选出结果，再次选举直到出结果。</li></ol><p><code>故障转移</code>过程：</p><ol><li>选一个从服务器，执行==slave of no one==命令，让它为主服务器。</li><li>所有从服务器执行==slave of ip port==，成为新主服务器的从服务器。</li><li>将已下线的主节点设置为新主服务器的从服务器。</li></ol><p><code>新主服务器挑选</code>流程：</p><ol><li><p>删除下线的断线的从服务器</p></li><li><p>删除 5 秒内未响应 sentinel 的 ==INFO== 命令的从服务器</p></li><li><p>删除和下线主服务器超时时间超过==down-after-milliseconds==10 倍的从服务器</p></li><li><p>根据 slave 优先级，选取最高的</p></li><li><p>优先级相同，复制偏移量最大的 slave</p></li><li><p>偏移量相同，服务器 run id 排序，取最小的</p></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-分片集群">3. 分片集群<a class="hash-link" href="#3-分片集群" title="标题的直接链接">​</a></h3><p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p><p>集群特征：</p><ul><li><p>每个节点都保存不同数据</p></li><li><p>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽.</p></li><li><p>节点的 fail 是通过集群中超过半数的节点检测失效时才生效.</p></li><li><p>客户端与 redis 节点直连,不需要中间 proxy 层连接集群中任何一个可用节点都可以访问到数据</p></li><li><p>redis-cluster 把所有的物理节点映射到<!-- -->[0-16383]<!-- -->slot（插槽）上，实现动态伸缩</p></li></ul><p>每个节点都保存不同数据，数据分布在哈希槽上。</p><p>哈希槽：16384 个槽，这些槽分配到不同的实例中，不能有剩余。</p><p>槽定位：每个 key 进行 CRC16 算法再对槽数取模，找到对应位置。</p><blockquote><p>如果数据迁移或者加入新节点后，哈希槽可能会发生变化，客户端此时的请求到了旧的节点上，会返回一个 MOVED 错误，并且指引客户端转向正确的节点来请求。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="槽指派过程">槽指派过程<a class="hash-link" href="#槽指派过程" title="标题的直接链接">​</a></h4><p>命令：==cluster addslots 槽号==。</p><ul><li><p>更新 clusterState 数组，将指定槽 slots<!-- -->[i]<!-- --> 指向当前 clusterNode。</p></li><li><p>更新 clusterNode 的 slots 数据，将指定槽 slots<!-- -->[i]<!-- -->处的值更新为 1。</p></li><li><p>向集群中的其他节点发信息，将 clusterNode 的 slots 数组发送给其他节点，告诉他们自己负责那个槽。</p></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="重新分片">重新分片<a class="hash-link" href="#重新分片" title="标题的直接链接">​</a></h4><p>重新分配 A 节点的槽给 B 节点处理：</p><ul><li>MIGRATING A 节点设置，如果请求过来 key 还在当前节点负责的槽，那么会处理。否则-ask 重定向到迁移节点-B 节点。</li><li>IMPORTING 接受到 asking 命令才会接受查询这个哈希槽的请求。</li></ul><blockquote><p>重新分片期间，数据部分迁移，客户端发来查询时的处理：</p><ul><li>先在源节点查找，如果找到，直接执行命令并返回结果。</li><li>如果找不到，说明可能迁移到目标节点了，源节点返回一个 ASK 错误，指引客户端到目标节点查找，命令带有 REDIS_ASKING 标识，目标节点会破例执行这个命令一次。</li></ul><p>注意：ASK 和 moved 错误都是隐式的。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="故障转移">故障转移<a class="hash-link" href="#故障转移" title="标题的直接链接">​</a></h4><ol><li><p>每个节点定期向其他节点发送==Ping==，如果一定时间内没有 pong 就认为疑似下线 ==PFAIL==。</p></li><li><p>发送消息给其他节点，疑似下线的信息会同步。</p></li><li><p>如果半数以上的主节点都认为某个主节点疑似下线，那么就标记为已下线 ==FAIL==。</p></li><li><p>发送消息给其他节点，从节点知道自己的主节点挂了就要选举。</p></li><li><p>选举一个节点作为最新的节点，执行==slaveof no one==。</p></li><li><p>新的主节点撤销原来节点的槽指派，指派给自己，修改 clusterNode 和 clusterState 结构。</p></li><li><p>新的主节点向集群广播 ==pong==消息，其他节点知道有新的主节点产生，更新结构。</p></li><li><p>新的节点向剩余从节点发送新的 ==slaveof== 指令，成为自己的从节点。</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-的常用数据类型有哪些">Redis 的常用数据类型有哪些？<a class="hash-link" href="#redis-的常用数据类型有哪些" title="标题的直接链接">​</a></h2><p>支持多种类型的数据结构，主要区别是 value 存储的数据格式不同：</p><ul><li><p>string：最基本的数据类型，二进制安全的字符串，最大 512M。</p><blockquote><p>底层：SDS，简单动态字符串。</p><p>场景：缓存，分布式 ID 自增，分布式锁</p></blockquote></li><li><p>list：按照添加顺序保持顺序的字符串列表。</p><blockquote><p>底层：</p><p>场景：点赞列表。</p></blockquote></li><li><p>set：无序的字符串集合，不存在重复的元素。</p><blockquote><p>底层：</p><p>场景：关注（点赞 ）、取关、共同关注。</p></blockquote></li><li><p>sorted set：已排序的字符串集合。</p><blockquote><p>底层：</p><p>场景：排行榜</p></blockquote></li><li><p>hash：key-value 对格式</p><blockquote><p>底层：</p><p>场景：购物车，用户 id 作为 key，商品 id，数量</p></blockquote></li></ul><p>三种特殊数据类型：</p><ul><li><p>Bitmap：位图，二进制位数组</p><blockquote><p>底层：SDS</p><p>场景：用户签到功能</p></blockquote></li><li><p>HyperLogLog：不精确的统计</p><blockquote><p>原理：计算低位 0 的个数</p><p>场景：统计页面 UV</p></blockquote></li><li><p>Geospecial</p><blockquote><p>场景：附近的人</p></blockquote></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="聊一下-redis-事务机制">聊一下 Redis 事务机制<a class="hash-link" href="#聊一下-redis-事务机制" title="标题的直接链接">​</a></h2><p><strong>相关资料：</strong></p><p>参考：<a href="http://redisdoc.com/topic/transaction.html" target="_blank" rel="noopener noreferrer">http://redisdoc.com/topic/transaction.html</a></p><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的。Redis 会将一个事务中的所有命令序列化，然后按顺序执行。但是 Redis 事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p><ul><li><code>MULTI</code>: 用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>待执行命令队列</strong>中</li><li><code>EXEC</code>：按顺序执行命令队列内的所有命令。返回所有命令的返回值。事务执行过程中，Redis 不会执行其它事务的命令。</li><li><code>DISCARD</code>：清空命令队列，并放弃执行事务， 并且客户端会从事务状态中退出</li><li><code>WATCH</code>：Redis 的乐观锁机制，利用 compare-and-set（CAS）原理，可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行</li></ul><p>使用事务时可能会遇上以下两种错误：</p><ul><li>执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。<ul><li>Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</li></ul></li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<ul><li>即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行，不会回滚。</li></ul></li></ul><p>为什么 Redis 不支持回滚（roll back）？</p><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由<strong>编程错误</strong>造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p><p><strong>面试话术：</strong></p><p>Redis 事务其实是把一系列 Redis 命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis 事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。</p><p>为了弥补不能回滚的问题，Redis 会在事务入队时就检查命令，如果命令异常则会放弃整个事务。</p><p>因此，只要程序员编程是正确的，理论上说 Redis 会正确执行所有事务，无需回滚。</p><p>面试官：如果事务执行一半的时候 Redis 宕机怎么办？</p><p>Redis 有持久化机制，因为可靠性问题，我们一般使用 AOF 持久化。事务的所有命令也会写入 AOF 文件，但是如果在执行 EXEC 命令之前，Redis 已经宕机，则 AOF 文件中事务不完整。使用 <code>redis-check-aof</code> 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-的-key-过期策略">Redis 的 Key 过期策略<a class="hash-link" href="#redis-的-key-过期策略" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="参考资料"><strong>参考资料：</strong><a class="hash-link" href="#参考资料" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="为什么需要内存回收">为什么需要内存回收？<a class="hash-link" href="#为什么需要内存回收" title="标题的直接链接">​</a></h4><ul><li>1、在 Redis 中，set 指令可以指定 key 的过期时间，当过期时间到达以后，key 就失效了；</li><li>2、Redis 是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。</li></ul><p>基于以上两点，为了保证 Redis 能继续提供可靠的服务，Redis 需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。</p><p>Redis 的内存回收主要分为过期删除策略和内存淘汰策略两部分。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="过期删除策略">过期删除策略<a class="hash-link" href="#过期删除策略" title="标题的直接链接">​</a></h4><p>删除达到过期时间的 key。</p><ul><li>1）定时删除</li></ul><p>对于每一个设置了过期时间的 key 都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的 CPU 资源去处理过期的数据，会影响 Redis 的吞吐量和响应时间。</p><ul><li>2）惰性删除</li></ul><p>当访问一个 key 时，才判断该 key 是否过期，过期则删除。该策略能最大限度地节省 CPU 资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期 key 没有被再次访问，因此不会被清除，导致占用了大量的内存。</p><blockquote><p>在计算机科学中，懒惰删除（英文：lazy deletion）指的是从一个散列表（也称哈希表）中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。</p></blockquote><ul><li>3）定期删除</li></ul><p>每隔一段时间，扫描 Redis 中过期 key 字典，并清除部分过期的 key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p><p>在 Redis 中，<code>同时使用了定期删除和惰性删除</code>。不过 Redis 定期删除采用的是随机抽取的方式删除部分 Key，因此不能保证过期 key 100%的删除。</p><p>Redis 为了保证提供高性能服务，被动删除过期的 key，采用了贪心策略/概率算法，默认每隔 10 秒扫描一次，具体策略如下：</p><ol><li>从过期字典（设置了过期时间的 key 的集合）中随机选择 20 个 key，检查其是否过期</li><li>删除其中已经过期的 key</li><li>如果删除的过期 key 数量大于 25%，则重复步骤 1</li></ol><p>Redis 结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期 key 较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期 key 堆积在内存中，导致 redis 内存耗尽，当内存耗尽之后，有新的 key 到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的 key？</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="内存淘汰策略">内存淘汰策略<a class="hash-link" href="#内存淘汰策略" title="标题的直接链接">​</a></h2><p>Redis 的内存淘汰策略，是指内存达到 maxmemory 极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p><p>Redis 的内存淘汰机制包括：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，移除最近最少使用的 key（这个是最常用的）。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，随机移除某个 key。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，移除最近最少使用的 key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，随机移除某个 key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，有更早过期时间的 key 优先移除。</li></ul><blockquote><p>在配置文件中，通过 maxmemory-policy 可以配置要使用哪一个淘汰机制。</p></blockquote><p>什么时候会进行淘汰？</p><p>Redis 会在<strong>每一次处理命令的时候</strong>（processCommand 函数调用 freeMemoryIfNeeded）判断<strong>当前 redis 是否达到了内存的最大限制</strong>，如果达到限制，则使用对应的算法去处理需要删除的 key。</p><p>在淘汰 key 时，Redis 默认最常用的是 LRU 算法（Latest Recently Used）。Redis 通过在每一个 redisObject 保存 lru 属性来保存 key 最近的访问时间，在实现 LRU 算法时直接读取 key 的 lru 属性。</p><p>具体实现时，Redis 遍历每一个 db，从每一个 db 中随机抽取一批样本 key，默认是 3 个 key，再从这 3 个 key 中，删除最近最少使用的 key。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="面试话术">面试话术：<a class="hash-link" href="#面试话术" title="标题的直接链接">​</a></h3><p>Redis 过期策略包含定期删除和惰性删除两部分。定期删除是在 Redis 内部有一个定时任务，会定期删除一些过期的 key。惰性删除是当用户查询某个 Key 时，会检查这个 Key 是否已经过期，如果没过期则返回用户，如果过期则删除。</p><p>但是这两个策略都无法保证过期 key 一定删除，漏网之鱼越来越多，还可能导致内存溢出。当发生内存不足问题时，Redis 还会做内存回收。内存回收采用 LRU 策略，就是最近最少使用。其原理就是记录每个 Key 的最近使用时间，内存回收时，随机抽取一些 Key，比较其使用时间，把最老的几个删除。</p><p>Redis 的逻辑是：最近使用过的，很可能再次被使用</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-在项目中的哪些地方有用到">Redis 在项目中的哪些地方有用到?<a class="hash-link" href="#redis-在项目中的哪些地方有用到" title="标题的直接链接">​</a></h2><p>（1）共享 session</p><p>在分布式系统下，服务会部署在不同的 tomcat，因此多个 tomcat 的 session 无法共享，以前存储在 session 中的数据无法实现共享，可以用 redis 代替 session，解决分布式系统间数据共享问题。</p><p>（2）数据缓存</p><p>Redis 采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到 redis 中，这样用户请求时优先从 redis 中读取，减少数据库压力，提高并发能力。</p><p>（3）异步队列</p><p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。而且 Redis 中还有 pub/sub 这样的专用结构，用于 1 对 N 的消息通信模式。</p><p>（4）分布式锁</p><p>Redis 中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-的缓存击穿缓存雪崩缓存穿透">Redis 的缓存击穿、缓存雪崩、缓存穿透<a class="hash-link" href="#redis-的缓存击穿缓存雪崩缓存穿透" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1缓存穿透">1）缓存穿透<a class="hash-link" href="#1缓存穿透" title="标题的直接链接">​</a></h3><p>参考资料：</p><ul><li><p>什么是缓存穿透</p><ul><li>正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为<strong>缓存穿透</strong>。</li></ul></li><li><p>穿透带来的问题</p><ul><li>试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的 id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。</li></ul></li><li><p>解决办法</p><ul><li>缓存空值：之所以会发生穿透，就是因为缓存中没有存储这些空数据的 key。从而导致每次查询都到数据库去了。那么我们就可以为这些 key 对应的值设置为 null 丢到缓存里面去。后面再出现查询这个 key 的请求的时候，直接返回 null 。这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。</li><li>BloomFilter（布隆过滤）：hash+bitmap，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。</li></ul></li></ul><p><strong>话术：</strong></p><p>缓存穿透有两种解决方案：<strong>其一</strong>是把不存在的 key 设置 null 值到缓存中。<strong>其二</strong>是使用布隆过滤器，在查询缓存前先通过布隆过滤器判断 key 是否存在，存在再去查询缓存。</p><p>设置 null 值可能被恶意针对，攻击者使用大量不存在的不重复 key ，那么方案一就会缓存大量不存在 key 数据。此时我们还可以对 Key 规定格式模板，然后对不存在的 key 做<strong>正则规范</strong>匹配，如果完全不符合就不用存 null 值到 redis，而是直接返回错误。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2缓存击穿">2）缓存击穿<a class="hash-link" href="#2缓存击穿" title="标题的直接链接">​</a></h3><p><strong>相关资料</strong>：</p><ul><li>什么是缓存击穿？</li></ul><p>key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>当这个 key 在失效的瞬间，redis 查询失败，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><ul><li>解决方案：<ul><li>使用互斥锁(mutex key)：mutex，就是互斥。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用 Redis 的 SETNX 去 set 一个互斥 key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现互斥的效果。</li><li>设置热点数据永不过期</li><li>软过期：也就是逻辑过期，不使用 redis 提供的过期时间，而是业务层在数据中存储过期时间信息。查询时由业务程序判断是否过期，如果数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。</li></ul></li></ul><p>推荐使用互斥锁，因为软过期会有业务逻辑侵入和额外的判断。</p><p><strong>面试话术</strong>：</p><p>缓存击穿主要担心的是某个 Key 过期，更新缓存时引起对数据库的突发高并发访问。因此我们可以在更新缓存时采用互斥锁控制，只允许一个线程去更新缓存，其它线程等待并重新读取缓存。例如 Redis 的 setnx 命令就能实现互斥效果。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3缓存雪崩">3）缓存雪崩<a class="hash-link" href="#3缓存雪崩" title="标题的直接链接">​</a></h3><p><strong>相关资料</strong>：</p><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效或者 Redis 服务器宕机。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p><p>解决方案：</p><ul><li>数据分类分批处理：采取不同分类数据，缓存不同周期</li><li>相同分类数据：采用固定时长加随机数方式设置缓存</li><li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li><li>避免 redis 节点宕机引起雪崩，搭建主从集群，保证高可用</li></ul><p><strong>面试话术：</strong></p><p>解决缓存雪崩问题的关键是让缓存 Key 的过期时间分散。因此我们可以把数据按照业务分类，然后设置不同过期时间。相同业务类型的 key，设置固定时长加随机数。尽可能保证每个 Key 的过期时间都不相同。</p><p>另外，Redis 宕机也可能导致缓存雪崩，因此我们还要搭建 Redis 主从集群及哨兵监控，保证 Redis 的高可用。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="缓存冷热数据分离">缓存冷热数据分离<a class="hash-link" href="#缓存冷热数据分离" title="标题的直接链接">​</a></h2><p><strong>背景资料</strong>：</p><p>Redis 使用的是内存存储，当需要海量数据存储时，成本非常高。</p><p>经过调研发现，当前主流 DDR3 内存和主流 SATA SSD 的单位成本价格差距大概在 20 倍左右，为了优化 redis 机器综合成本，我们考虑实现基于<strong>热度统计 的数据分级存储</strong>及数据在 RAM/FLASH 之间的动态交换，从而大幅度降低成本，达到性能与成本的高平衡。</p><p>基本思路：基于 key 访问次数(LFU)的热度统计算法识别出热点数据，并将热点数据保留在 redis 中，对于无访问/访问次数少的数据则转存到 SSD 上，如果 SSD 上的 key 再次变热，则重新将其加载到 redis 内存中。</p><p>目前流行的高性能磁盘存储，并且遵循 Redis 协议的方案包括：</p><ul><li>SSDB：<a href="http://ssdb.io/zh_cn/" target="_blank" rel="noopener noreferrer">http://ssdb.io/zh_cn/</a></li><li>RocksDB：<a href="https://rocksdb.org.cn/" target="_blank" rel="noopener noreferrer">https://rocksdb.org.cn/</a></li></ul><p>因此，我们就需要在应用程序与缓存服务之间引入代理，实现 Redis 和 SSD 之间的切换，如图：</p><p>这样的代理方案阿里云提供的就有。当然也有一些开源方案，例如：<a href="https://github.com/JingchengLi/swapdb" target="_blank" rel="noopener noreferrer">https://github.com/JingchengLi/swapdb</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-实现分布式锁">Redis 实现分布式锁<a class="hash-link" href="#redis-实现分布式锁" title="标题的直接链接">​</a></h2><p>分布式锁要满足的条件：</p><ul><li>多进程互斥：同一时刻，只有一个进程可以获取锁</li><li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li><li>阻塞锁（可选）：获取锁失败时可否重试</li><li>重入锁（可选）：获取锁的代码递归调用时，依然可以获取锁</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1最基本的分布式锁">1）最基本的分布式锁：<a class="hash-link" href="#1最基本的分布式锁" title="标题的直接链接">​</a></h3><p>利用 Redis 的 setnx 命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。但是为了保证服务宕机时也可以释放锁，需要利用 expire 命令给锁设置一个有效期</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">setnx lock thread-01 # 尝试获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">expire lock 10 # 设置有效期</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>面试官问题 1</strong>：如果 expire 之前服务宕机怎么办？</p><p>要保证 setnx 和 expire 命令的原子性。redis 的 set 命令可以满足：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">set key value [NX] [EX time]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>需要添加 nx 和 ex 的选项：</p><ul><li>NX：与 setnx 一致，第一次执行成功</li><li>EX：设置过期时间</li></ul><p><strong>面试官问题 2</strong>：释放锁的时候，如果自己的锁已经过期了，此时会出现安全漏洞，如何解决？</p><p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p><p>但是这两步操作要保证原子性，需要通过 Lua 脚本来实现。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&quot;del&quot;,KEYS[1])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-lua codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lua codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return redis.call(&quot;del&quot;, KEYS[1])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2可重入分布式锁">2）可重入分布式锁<a class="hash-link" href="#2可重入分布式锁" title="标题的直接链接">​</a></h3><p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p><p>下面我们假设锁的 key 为“<code>lock</code>”，hashKey 是当前线程的 id：“<code>threadId</code>”，锁自动释放时间假设为 20</p><p>获取锁的步骤：</p><ul><li>1、判断 lock 是否存在 <code>EXISTS lock</code><ul><li>存在，说明有人获取锁了，下面判断是不是自己的锁<ul><li>判断当前线程 id 作为 hashKey 是否存在：<code>HEXISTS lock threadId</code><ul><li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li><li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤 3</li></ul></li></ul></li><li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li><li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li></ul></li></ul><p>释放锁的步骤：</p><ul><li>1、判断当前线程 id 作为 hashKey 是否存在：<code>HEXISTS lock threadId</code><ul><li>不存在，说明锁已经失效，不用管了</li><li>存在，说明锁还在，重入次数减 1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li></ul></li><li>2、判断重入次数是否为 0：<ul><li>为 0，说明锁全部释放，删除 key：<code>DEL lock</code></li><li>大于 0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li></ul></li></ul><p>对应的 Lua 脚本如下：</p><p>首先是获取锁：</p><div class="language-lua codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lua codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">local key = KEYS[1]; -- 锁的key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local threadId = ARGV[1]; -- 线程唯一标识</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local releaseTime = ARGV[2]; -- 锁的自动释放时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if(redis.call(&#x27;exists&#x27;, key) == 0) then -- 判断是否存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;hset&#x27;, key, threadId, &#x27;1&#x27;); -- 不存在, 获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;expire&#x27;, key, releaseTime); -- 设置有效期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 1; -- 返回结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if(redis.call(&#x27;hexists&#x27;, key, threadId) == 1) then -- 锁已经存在，判断threadId是否是自己</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;hincrby&#x27;, key, threadId, &#x27;1&#x27;); -- 不存在, 获取锁，重入次数+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;expire&#x27;, key, releaseTime); -- 设置有效期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 1; -- 返回结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return 0; -- 代码走到这里,说明获取锁的不是自己，获取锁失败</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后是释放锁：</p><div class="language-lua codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-lua codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">local key = KEYS[1]; -- 锁的key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local threadId = ARGV[1]; -- 线程唯一标识</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local releaseTime = ARGV[2]; -- 锁的自动释放时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (redis.call(&#x27;HEXISTS&#x27;, key, threadId) == 0) then -- 判断当前锁是否还是被自己持有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nil; -- 如果已经不是自己，则直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local count = redis.call(&#x27;HINCRBY&#x27;, key, threadId, -1); -- 是自己的锁，则重入次数-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (count &gt; 0) then -- 判断是否重入次数是否已经为0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;EXPIRE&#x27;, key, releaseTime); -- 大于0说明不能释放锁，重置有效期然后返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nil;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;DEL&#x27;, key); -- 等于0说明可以释放锁，直接删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nil;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3高可用的锁">3）高可用的锁<a class="hash-link" href="#3高可用的锁" title="标题的直接链接">​</a></h3><p><code>面试官问题</code>：redis 分布式锁依赖与 redis，如果 redis 宕机则锁失效。如何解决？</p><p>此时大多数同学会回答说：搭建主从集群，做数据备份。</p><p>这样就进入了陷阱，因为面试官的下一个问题就来了：</p><p><code>面试官问题</code>：如果搭建主从集群做数据备份时，进程 A 获取锁，master 还没有把数据备份到 slave，master 宕机，slave 升级为 master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p><p>关于这个问题，Redis 官网给出了解决方案，使用 RedLock 思路可以解决：</p><blockquote><p>在 Redis 的分布式环境中，我们假设有 N 个 Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在 Redis 单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有 5 个 Redis master 节点，这是一个比较合理的设置，所以我们需要在 5 台机器上面或者 5 台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p><p>为了取到锁，客户端应该执行以下操作:</p><ol><li>获取当前 Unix 时间，以毫秒为单位。</li><li>依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。</li><li>客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li><li>如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</li><li>如果因为某些原因，获取锁失败（<em>没有</em>在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功）。</li></ol></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="如何实现数据库与缓存数据一致">如何实现数据库与缓存数据一致？<a class="hash-link" href="#如何实现数据库与缓存数据一致" title="标题的直接链接">​</a></h2><p>面试话术：</p><p>实现方案有下面几种：</p><ul><li>本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对 Redis 的修改逻辑，保证一致。</li><li>跨服务缓存同步：服务 A 调用了服务 B，并对查询结果缓存。服务 B 数据库修改，可以通过 MQ 通知服务 A，服务 A 修改 Redis 缓存数据</li><li>通用方案：使用 Canal 框架，伪装成 MySQL 的 salve 节点，监听 MySQL 的 binLog 变化，然后修改 Redis 缓存数据</li></ul><p>3、<strong>更新数据库 + 更新缓存</strong>方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p><p>4、在<strong>更新数据库 + 删除缓存</strong>的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p><p>5、在「<strong>先更新数据库，再删除缓存</strong>」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p><p>6、在「<strong>先更新数据库，再删除缓存</strong>」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yntx-it/yntx-black-iron-tutorial-fronted/tree/master/shared/docs/interview/interview-redis.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/interview/interview-mysql"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">MySQL 篇</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/interview/interview-mq"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">MQ 篇</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#redis-与-memcache-的区别" class="table-of-contents__link toc-highlight">Redis 与 Memcache 的区别？</a></li><li><a href="#redis-的单线程为什么那么快" class="table-of-contents__link toc-highlight">Redis 的单线程为什么那么快</a></li><li><a href="#redis-的持久化方案由哪些" class="table-of-contents__link toc-highlight">Redis 的持久化方案由哪些？</a></li><li><a href="#redis-的集群方式有哪些" class="table-of-contents__link toc-highlight">Redis 的集群方式有哪些？</a><ul><li><a href="#1-主从集群" class="table-of-contents__link toc-highlight">1. 主从集群</a></li><li><a href="#2-sentinel-集群" class="table-of-contents__link toc-highlight">2. Sentinel 集群</a></li><li><a href="#3-分片集群" class="table-of-contents__link toc-highlight">3. 分片集群</a></li></ul></li><li><a href="#redis-的常用数据类型有哪些" class="table-of-contents__link toc-highlight">Redis 的常用数据类型有哪些？</a></li><li><a href="#聊一下-redis-事务机制" class="table-of-contents__link toc-highlight">聊一下 Redis 事务机制</a></li><li><a href="#redis-的-key-过期策略" class="table-of-contents__link toc-highlight">Redis 的 Key 过期策略</a><ul><li><a href="#参考资料" class="table-of-contents__link toc-highlight"><strong>参考资料：</strong></a></li></ul></li><li><a href="#内存淘汰策略" class="table-of-contents__link toc-highlight">内存淘汰策略</a><ul><li><a href="#面试话术" class="table-of-contents__link toc-highlight">面试话术：</a></li></ul></li><li><a href="#redis-在项目中的哪些地方有用到" class="table-of-contents__link toc-highlight">Redis 在项目中的哪些地方有用到?</a></li><li><a href="#redis-的缓存击穿缓存雪崩缓存穿透" class="table-of-contents__link toc-highlight">Redis 的缓存击穿、缓存雪崩、缓存穿透</a><ul><li><a href="#1缓存穿透" class="table-of-contents__link toc-highlight">1）缓存穿透</a></li><li><a href="#2缓存击穿" class="table-of-contents__link toc-highlight">2）缓存击穿</a></li><li><a href="#3缓存雪崩" class="table-of-contents__link toc-highlight">3）缓存雪崩</a></li></ul></li><li><a href="#缓存冷热数据分离" class="table-of-contents__link toc-highlight">缓存冷热数据分离</a></li><li><a href="#redis-实现分布式锁" class="table-of-contents__link toc-highlight">Redis 实现分布式锁</a><ul><li><a href="#1最基本的分布式锁" class="table-of-contents__link toc-highlight">1）最基本的分布式锁：</a></li><li><a href="#2可重入分布式锁" class="table-of-contents__link toc-highlight">2）可重入分布式锁</a></li><li><a href="#3高可用的锁" class="table-of-contents__link toc-highlight">3）高可用的锁</a></li></ul></li><li><a href="#如何实现数据库与缓存数据一致" class="table-of-contents__link toc-highlight">如何实现数据库与缓存数据一致？</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/java">Java</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 与你同行技术, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1bbccddd.js"></script>
<script src="/assets/js/main.ce06d064.js"></script>
</body>
</html>