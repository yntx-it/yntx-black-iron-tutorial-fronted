<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-interview/interview-concurrency">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">并发篇 | 与你同行-黑铁教程</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://yntx-it.github.io/yntx-black-iron-tutorial-fronted/docs/interview/interview-concurrency"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="并发篇 | 与你同行-黑铁教程"><meta data-rh="true" name="description" content="Java 线程的状态"><meta data-rh="true" property="og:description" content="Java 线程的状态"><link data-rh="true" rel="icon" href="/yntx-black-iron-tutorial-fronted/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://yntx-it.github.io/yntx-black-iron-tutorial-fronted/docs/interview/interview-concurrency"><link data-rh="true" rel="alternate" href="https://yntx-it.github.io/yntx-black-iron-tutorial-fronted/docs/interview/interview-concurrency" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://yntx-it.github.io/yntx-black-iron-tutorial-fronted/docs/interview/interview-concurrency" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/yntx-black-iron-tutorial-fronted/blog/rss.xml" title="与你同行-黑铁教程 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/yntx-black-iron-tutorial-fronted/blog/atom.xml" title="与你同行-黑铁教程 Atom Feed"><link rel="stylesheet" href="/yntx-black-iron-tutorial-fronted/assets/css/styles.39c269dc.css">
<link rel="preload" href="/yntx-black-iron-tutorial-fronted/assets/js/runtime~main.5ce9c5ac.js" as="script">
<link rel="preload" href="/yntx-black-iron-tutorial-fronted/assets/js/main.ee7b2638.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/yntx-black-iron-tutorial-fronted/"><div class="navbar__logo"><img src="/yntx-black-iron-tutorial-fronted/img/logo.svg" alt="黑铁教程 Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/yntx-black-iron-tutorial-fronted/img/logo.svg" alt="黑铁教程 Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">与你同行-黑铁教程</b></a><a class="navbar__item navbar__link" href="/yntx-black-iron-tutorial-fronted/docs/java">Java教程</a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/yntx-black-iron-tutorial-fronted/docs/interview">面试宝典</a><a class="navbar__item navbar__link" href="/yntx-black-iron-tutorial-fronted/blog">博客</a><a class="navbar__item navbar__link" href="/yntx-black-iron-tutorial-fronted/docs/introduction">项目介绍</a><a href="https://github.com/yntx-it/yntx-black-iron-tutorial-fronted" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active" href="/yntx-black-iron-tutorial-fronted/docs/interview">常见面试题</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-algorithm">算法篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-design">设计模式篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-base">基础篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-collection">集合篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-concurrency">并发篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-jvm">JVM 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-microservice">微服务篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-mysql">MySQL 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-redis">Redis 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-mq">MQ 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-spring">Spring 篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-mybatis">MyBatis 的原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-other">补充篇</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/yntx-black-iron-tutorial-fronted/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/yntx-black-iron-tutorial-fronted/docs/interview"><span itemprop="name">常见面试题</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">并发篇</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>并发篇</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="java-线程的状态">Java 线程的状态<a class="hash-link" href="#java-线程的状态" title="标题的直接链接">​</a></h2><ul><li><code>新建 New</code>
当一个线程对象被创建，但还未调用 start 方法时处于新建状态。
此时未与操作系统底层线程关联。</li><li><code>可运行 Runnable</code>
调用了 start 方法，就会由新建进入可运行。
此时与底层线程关联，由操作系统调度执行。</li><li><code>终结 Terminated</code>
线程内代码已经执行完毕，由可运行进入终结。
此时会取消与底层线程关联。</li><li><code>阻塞 Blocked</code>
当获取锁失败后，由可运行进入 Monitor 的阻塞队列阻塞，此时不占用 cpu 时间。
当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的阻塞线程，唤醒后的线程进入可运行
状态。</li><li><code>等待 Waiting</code>
当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从可运行状态释放锁进入
Monitor 等待集合等待，同样不占用 cpu 时间
当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的等待线
程，恢复为可运行状态</li><li><code>有时限等待 Timed Waiting</code>
当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从可运行状态释放锁进
入 Monitor 等待集合进行有时限等待，同样不占用 cpu 时间
当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的有时限等
待线程，恢复为可运行状态，并重新去竞争锁
如果等待超时，也会从有时限等待状态恢复为可运行状态，并重新去竞争锁
还有一种情况是调用 sleep(long) 方法也会从可运行状态进入有时限等待状态，但与 Monitor
无关，不需要主动唤醒，超时时间到自然恢复为可运行状态</li></ul><blockquote><p>其它情况（只需了解）</p><ul><li><p>可以用 interrupt() 方法打断等待、有时限等待的线程，让它们恢复为可运行状态</p></li><li><p>park，unpark 等方法也可以让线程等待和唤醒</p></li></ul></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="线程池">线程池<a class="hash-link" href="#线程池" title="标题的直接链接">​</a></h2><h4 class="anchor anchorWithStickyNavbar_LWe7" id="七大参数">七大参数：<a class="hash-link" href="#七大参数" title="标题的直接链接">​</a></h4><ul><li><code>corePoolSize</code>：核心线程数，池中会保留的核心线程数</li><li><code>maximumPoolSize</code>：最大线程数 = 核心线程数 + 救急线程数</li><li><code>keepAliveTime</code>：救急线程存活时间，如果该时间内没有任务，该线程被释放</li><li><code>unit</code>：救急线程存活时间单位，如秒、毫秒等</li><li><code>workQueue</code>：工作队列，当没有空闲核心线程时，任务会加入到该队列，当队列满时会创建救急线程执行任务</li><li><code>threadFactory</code>：线程工厂，定制创建线程的名字，是否守护线程等等</li><li><code>handler</code>：拒绝策略，当所有线程都在繁忙，workQueue 也满了时，会触发拒绝策略，JDK 提供的拒绝策略有四种：<ul><li><strong>AbortPolicy</strong>：拒绝执行，直接抛出异常。</li><li><strong>CallerRunPolicy</strong>：由调用者创建线程执行任务。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务。</li><li><strong>DiscardOldestPolicy</strong>：丢弃最早进入队列的任务。</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="如何分配线程数量">如何分配线程数量？<a class="hash-link" href="#如何分配线程数量" title="标题的直接链接">​</a></h4><p>假设我们的 CPU 的线程数为 N，一般的经验做法是：</p><ul><li>CPU 密集型：N+1（CPU 一直全速运行）</li><li>IO 密集型：2N（并不是一直在执行任务，可能会阻塞）</li></ul><p>具体开多少还是得压测才能确定下来。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要用阻塞队列而不用非阻塞队列">为什么要用阻塞队列而不用非阻塞队列？<a class="hash-link" href="#为什么要用阻塞队列而不用非阻塞队列" title="标题的直接链接">​</a></h4><p>线程池是采用生产者-消费者模式设计的，线程池是消费者。</p><p>工作线程调用 take()方法获得任务，如果没有元素时会阻塞在 take()方法，释放 CPU 资源。当阻塞队列有任务时才被唤醒对应线程从队列中取出任务执行。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="execute-流程">execute 流程<a class="hash-link" href="#execute-流程" title="标题的直接链接">​</a></h4><ol><li>判断是 runnable 否为 null</li><li>获取 ctl 进而获取正在工作的线程数，判断是否小于核心线程数</li><li>创建核心线程，执行任务</li><li>如果添加核心线程数失败，重新获取 ctl</li><li>获取线程池状态，如果线程池正在运行，把任务加到阻塞队列</li><li>否则，尝试创建最大线程数（救急线程），成功返回 true，失败执行拒绝策略</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="wait和-sleep的区别">wait()和 sleep()的区别<a class="hash-link" href="#wait和-sleep的区别" title="标题的直接链接">​</a></h2><p><strong>共同点</strong>：都可以放弃 CPU 的使用权，进入等待状态，都可以被打断 interrupt() 唤醒。</p><p><strong>不同点</strong>：<strong>方法归属</strong>、<strong>醒来时机</strong>、<strong>锁的特性</strong> 三个方面。</p><ul><li>方法归属：wait 是 Object 的成员方法，每个对象都有 wait 方法；sleep 是线程 Thread 的静态方法。</li><li>醒来时机<ul><li>sleep(long)和 wait(long)都会在一定时间后醒来。</li><li>wait(long)和 wait()还可以被 notify 唤醒，wait()如果不唤醒就会一直等下去。</li></ul></li><li>锁的特性<ul><li>wait 方法的调用必须获取对象的锁，而 sleep 不用。</li><li>wait 方法执行后会释放对象锁，允许其他线程抢占锁；而 sleep 如果在 synchronized 代码块中执行，会一直持有锁，不释放。</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="生产者和消费者模式假死现象">生产者和消费者模式假死现象<a class="hash-link" href="#生产者和消费者模式假死现象" title="标题的直接链接">​</a></h2><p>生产者/消费者模型最终达到的目的是平衡生产者和消费者的处理能力，达到这个目的的过程中，并不要求只有一个生产者和一个消费者。可以多个生产者对应多个消费者，可以一个生产者对应一个消费者，可以多个生产者对应一个消费者。</p><p>假死就发生在上面三种场景下。理论分析就能说明问题，所以就不写代码了。开一个生产者线程/多个消费者线程、开多个生产者线程/消费者线程、开多个生产者线程/多个消费者线程都可以。假死指的是全部线程都进入了 WAITING 状态，那么程序就不再执行任何业务功能了，整个项目呈现停滞状态。</p><p>比方说有生产者 A 和生产者 B，缓冲区由于空了，消费者处于 WAITING。生产者 B 处于 WAITING，生产者 A 被消费者通知生产，生产者 A 生产出来的产品本应该通知消费者，结果通知了生产者 B，生产者 B 被唤醒，发现缓冲区满了，于是继续 WAITING。至此，两个生产者线程处于 WAITING，消费者处于 WAITING，系统假死。</p><p>上面的分析可以看出，假死出现的原因是因为 notify 的是同类，所以非单生产者/单消费者的场景，可以采取两种方法解决这个问题：</p><p>1、synchronized 用 notifyAll()唤醒所有线程、ReentrantLock 用 signalAll()唤醒所有线程</p><p>2、用 ReentrantLock 定义两个 Condition，一个表示生产者的 Condition，一个表示消费者的 Condition，唤醒的时候调用相应的 Condition 的 signal()方法就可以了</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="死锁">死锁<a class="hash-link" href="#死锁" title="标题的直接链接">​</a></h2><p>死锁的四个条件：</p><ul><li>互斥等待：不可破坏</li><li>请求和保持：一次性申请所有资源</li><li>不可抢占：申请不到主动释放</li><li>循环等待：按序申请</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized">synchronized<a class="hash-link" href="#synchronized" title="标题的直接链接">​</a></h2><p>synchronized 是 Java 的一个关键字，提供一种==互斥锁==，只允许一个线程进入同步代码块，其他线程只能阻塞等待。</p><p>加锁对象情况：</p><ul><li>如果修饰静态方法，就是给当前类的对象加锁。</li><li>如果修饰的是成员方法，就是给当前类的实例对象加锁。</li><li>如果修饰的是代码块，给传入的对象实例加锁。</li></ul><p>实现原理：编译后的字节码可以发现</p><ul><li>修饰方法时，会用 ACC_SYNCHRONIZED 关键字来标识</li><li>修饰代码块时，会 依赖 monitorenter 和 monitorexit 指令</li></ul><p><strong>首先讲一下对象的构成：</strong></p><p>在内存中的 Java 对象，分为==对象头==、==对象实际数据==和==对齐填充==。（数组还有长度字段）</p><p>重点在于对象头，对象头分为 ==mark word== 和 ==class point==。</p><p>mark word 主要存储==对象的 hashcode==、==GC 分代年龄==和==锁的相关信息==。</p><p><strong>monitor 对象的构成：</strong></p><p>每个对象都会有个对应的 ==object monitor== 对象，==monitor== 对象中主要存储三个部分，==owner== 、==wait set==、==entry list==。</p><p>==owner==：记录当前获得锁线程。</p><p>==wait set==：存放 wait()等待的线程。</p><p>==entry list==：存放等待获取锁额线程。</p><p>重量级锁：</p><p>JDK 1.6 之前是重量级锁，当线程进入同步代码块时，monitor 对象会把 当前线程的 ID 存储，并且设置 mark word 的 monitor 对象地址，把阻塞的线程存储到 entry list 中。</p><p>底层实现：依赖操作系统的 mutex 相关指令，所以会有 用户态 和 内核态之间的切换，性能损耗明显。</p><p>偏向锁：没有竞争的情况下，JVM 认为只有某个线程才会执行同步代码。</p><ol><li>在 Mark Word 会直接记录当前线程 ID，只要线程来执行代码了，会比较线程 ID 是否相等，相等就直接获取锁，执行代码。</li><li>如果不相等，就会使用 CAS 来修改 Mark word 中当前线程 ID，如果 CAS 成功，就获取锁，执行同步代码。</li><li>如果 CAS 失败，存在竞争环境，就会升级到轻量级锁。</li></ol><p>轻量级锁：</p><ol><li>当前线程会在栈帧下创建 Lock Record 锁记录，锁记录会把 Mark Word 的信息拷贝进去，且有多个 Owner 指针指向加锁对象。</li><li>线程执行到同步代码时，则用 CAS 试图将 Mark Word 的指向到线程栈帧的 Lock Record，假设 CAS 修改成功，则获取得到轻量级锁。</li><li>假设修改失败，则自旋（重试），自旋一定次数后，则升级为重量级锁。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="lock-和-synchronized-的区别">Lock 和 synchronized 的区别<a class="hash-link" href="#lock-和-synchronized-的区别" title="标题的直接链接">​</a></h2><p>主要从 <strong>语法</strong>、<strong>功能</strong>、<strong>性能</strong> 三个层面阐述。</p><ul><li><p>语法层面</p><ul><li>synchronized 是关键字，源码在 JVM 中，C++ 实现</li><li>Lock 是接口，源码在 JDK 中，Java 实现</li><li>使用 synchronized 时，临界区代码执行完会自动释放锁，而 Lock 要手动释放锁。</li></ul></li><li><p>功能层面</p><ul><li>都是悲观锁，互斥、同步、锁重入</li><li>Lock 提供了一些 synchronized 不具备的功能：获取等待状态、==公平锁==、==可打断==、==可超时==、==多条件变量（Condition）==</li><li>Lock 有适合不同场景的实现，如 ReentrantLock、ReentrantReadWriteLock</li></ul></li><li><p>性能层面</p><ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 通常性能比较好</li></ul></li></ul><blockquote><p>公平锁</p><ul><li>公平锁的公平体现</li><li>已经处在阻塞队列中的线程始终都是公平的，先进先出</li><li>公平锁是指未处于阻塞队列的线程来获取锁时，要判断队列是否为空，不为空就必须加入到队列</li><li>非公平锁是指未处阻塞队列的线程来获取锁时，直接抢占，谁抢到就是谁的</li><li>公平锁会降低吞吐量，一般不用</li></ul></blockquote><blockquote><p>条件变量</p><ul><li>ReentrantLock 中的条件变量类似于 synchronized 中的 wait，notify，用在线程获得锁发现条件不满足时，临时加入等待的链表结构</li><li>ReentrantLock 中的条件变量可以有多个，实现更加精细的等待和唤醒控制</li></ul></blockquote><blockquote><p>sychronized 抛异常可以释放锁，编译后字节码会有异常表，保证异常时正常解锁。</p><p>reentrantLock 可以跨方法释放锁吗，可以，但是最好不要，可重入锁是针对线程的，不是针对方法的。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="aqs-原理">AQS 原理<a class="hash-link" href="#aqs-原理" title="标题的直接链接">​</a></h2><p>AQS，全称为 ==AbstractQueueSynchronizer==，==抽象队列同步器==。它是 JDK 提供给我们的一个可以实现==锁==的框架，内部实现的关键就是维护了一个==先进先出的队列==和 ==state 状态变量==。</p><p>先进先出队列的载体就是 Node，节点标识当前的状态值，独占还是共享模式，前驱和后续节点。</p><p>AQS 定义了模板，具体实现由子类实现。</p><p>流程：把需要等待的线程以 Node 的形式存入先进先出的队列上，state 变量表示当前锁的状态。</p><p>子类：ReentrantLock、ReentrantReadWriteLock、Semphore、CountDownLatch</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="reentrantlock-加锁解锁流程">ReentrantLock 加锁、解锁流程<a class="hash-link" href="#reentrantlock-加锁解锁流程" title="标题的直接链接">​</a></h2><p>以非公平锁为例</p><p>加锁流程：lock -&gt; CAS -&gt; acquire -&gt; tryAcquire -&gt; state == 0 CAS -&gt; 当前线程获得锁？-&gt; 加入队列 -&gt; 头节点？-&gt; CAS -&gt; park</p><ol><li>调用 lock 时，CAS 尝试获取锁，获取成功就可以执行</li><li>CAS 获取锁失败，则调用 AQS 的 acquire 方法</li><li>调用子类的 tryAcquire 方法</li><li>判断当前的 state 是否等于 0，等于 0 说明没有线程持有锁，尝试获取锁</li><li>如果 CAS 成功，执行同步代码</li><li>如果 CAS 获取锁失败，判断当前线程是否持有锁，如果持有，更新 state 的值，获取锁（可重入）</li><li>如果 CAS 失败，且持有锁的不是当前线程，回到 tryAcquire 入队列</li><li>加入队列后，会判断前驱节点是不是头节点，如果是头节点又会用 CAS 尝试获取锁</li><li>如果没有获取锁，就会将前驱节点状态设置为 Signal</li><li>最后调用 LockSurpport.park() 方法将线程挂起</li></ol><p>解锁流程：</p><ol><li>调用 unlock()时，会调用 AQS 的 release 方法，release 方法又会调用子类的 tryRelease 方法</li><li>tryRelease 会把 state 减一，如果减到 0，说明当前线程把锁释放了</li><li>随后从 队尾 往前找节点，状态要 &lt;0 ，并且离头节点最近的老二节点唤醒，LockSupport.unpark</li><li>唤醒之后，被唤醒的线程尝试 CAS 获取锁，</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="volatile">volatile<a class="hash-link" href="#volatile" title="标题的直接链接">​</a></h2><p>volatile 是 Java 语言提供的一个关键字，它可以用来保证变量的可见性和有序性。</p><p>并发编程中需要考虑的三个问题：原子性、可见性和有序性。</p><blockquote><p>原子性</p><p>起因：多线程下，不同线程的指令发生了交错导致了共享变量的读写顺序混乱。</p><p>解决：volatile 只能保证变量的可见性和有序性，不能解决原子性问题。原子性问题需要用悲观锁或乐观锁来解决。</p></blockquote><blockquote><p>可见性</p><p>为了提升 CPU 的利用率，CPU 增加了寄存器和三级高速缓存，L1 和 L2 缓存是 CPU 私有的，如果两个线程同时把一个变量的数据加载到自己的高速缓存中，再分别修改，就引发了缓存一致性问题。为了解决缓存一致性问题，CPU 引入了总线锁和缓存锁。总线锁就是在总线上声明一个 Lock#信号，它可以保证只有当前 CPU 可以访问共享内存，其他的处理器请求会被阻塞，解决缓存不一致的问题。缓存锁是一种优化，如果当前 CPU 访问的数据已经缓存在其他 CPU 的高速缓存中，它就采用缓存一致性协议来保证缓存一致性。一致性协议的过程：当一个 CPU 修改了共享变量的值之后会刷新到主内存中，并通知其他 CPU 失效自己的缓存，每次重新去主内存加载。</p><p>起因：对共享变量所做的修改对其他线程不可见。</p><p>解决：valatile 底层实现就是会在修改命令前面加上一个 Lock# 信号，基于缓存锁或总线锁来保证结果可见。用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见。</p></blockquote><blockquote><p>有序性</p><p>起因：由于 CPU 指令重排序优化、CPU 缓存优化或编译器优化导致的指令实际执行顺序和编写顺序不一致。</p><p>解决：用 volatile 修饰共享变量，会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止排序的效果</p><p>写屏障：阻止<strong>上方</strong>其他<strong>写操作</strong>越过屏障到 volatile 变量的写之下。</p><p>读屏障：阻止<strong>下方</strong>其他<strong>读操作</strong>越过屏障到 volatile 变量的读之上。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="cas">CAS<a class="hash-link" href="#cas" title="标题的直接链接">​</a></h2><p>CAS 是 Java ==Unsafe 类==中的一个方法，全称是 ==compareAndSwap==，比较并交换，它是一个 CPU 原子性的指令，对应到 CPU 指令为 ==lock cmpxchg==，主要作用是==保证多线程环境下对共享变量修改的原子性==。</p><p>它的用法是：传入对应对象实例，对应变量的偏移量、预期值、新值，它会去比较内存中变量的值和传入的预期值是否相等，相等则修改为新值。</p><p>而这个操作在底层也会出现原子性问题，所以在==多核 CPU 环境下增加 Lock 指令对缓存或者总线去加锁==，来保证比较并替换的两个操作的原子性。</p><ol><li>JUC 中：Atomic 原子类实现</li><li>实现多线程对共享资源竞争的互斥性质：AQS，ConcurrentHashMap 等</li></ol><p>缺点：</p><ol><li>作为自旋锁的实现，会消耗大量 CPU 资源。并发高时性能不如加锁。</li><li>ABA 问题（AtomicStampedReference 加版本号解决）。</li><li>只能保证一个共享变量的原子操作，多个变量的原子操作需要使用锁或者 AtomicReference 类。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="悲观锁-vs-乐观锁">悲观锁 vs 乐观锁<a class="hash-link" href="#悲观锁-vs-乐观锁" title="标题的直接链接">​</a></h2><p>悲观锁：线程占有了锁，才能去操作共享变量，每次只有一个线程可以获得锁，获取锁失败的线程都阻塞。</p><blockquote><p>线程需要进入阻塞状态，再到唤醒状态。导致上下文切换频繁，影响性能。</p><p>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会。</p></blockquote><p>乐观锁：无需加锁，每次只有一个线程可以成功修改共享变量，其他线程不停重试，直到成功。</p><blockquote><p>线程一直运行，不需要阻塞，不会发生线程上下文切换。</p><p>需要多核 CPU 支持，线程数不应超过 CPU 核数。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="semaphore">Semaphore<a class="hash-link" href="#semaphore" title="标题的直接链接">​</a></h2><p>Semaphore 信号量，用来限制能够同时访问共享资源的线程上限。可以使用 Semaphore 限流，但只是单机版，分布式不能使用。</p><p>permits 许可数量。</p><p>acquire() 申请许可，如果申请不到就会进入 AQS 队列 park 阻塞。</p><p>release() 释放许可，唤醒 AQS 队列中的节点。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="countdownlatch-vs-cyclicbarrier">CountDownLatch vs CyclicBarrier<a class="hash-link" href="#countdownlatch-vs-cyclicbarrier" title="标题的直接链接">​</a></h2><p>CountDownLatch 倒计时器：允许一个或多个线程一直等待，直到完成他们的操作。</p><p>CyclicBarrier 循环栅栏：当线程达到某状态后，暂停下来等待其他线程，等到所有线程到达后，才继续执行。</p><p>CountDownLatch 用完了，就结束了，没法复用。而 CyclicBarrier 不一样，它可以复用。</p><p>两者都是线程同步的工具类，但他们的等待的主体不一样：CountDownLatch 一般是主线程/调用线程等待 await()，CyclicBarrier 一般是任务线程等待 await()。</p><p>这两个类都是基于 AQS 实现的。</p><p>当构建 CountDownLatch 对象时，我们会传参 count，这个参数会赋值给 AQ S 的关键变量 state，当执行 countdown 方法时，就是利用 cas 将 state 值减 1；执行 await()方法，就是判断这个 state 的值是否为 0，不为 0 就会加入到阻塞队列中，将该线程阻塞。当 state 为 0 时，会把队列里阻塞的线程节点都唤醒。</p><p>CyclicBarrier 是利用 ReentrantLock 来实现的，他是借助 ReentrantLock + Condition 来实现的。在构建 CyclicBarrier 的时候，传入的 parties 值会赋值给 count 和 parties 变量，每次调用 await() 时，会将 count-1，操作 count 值是直接使用 ReentrantLock 来保证线程安全性，如果 count 不为 0，则添加到 condition 队列中，如果 count 等于 0，就会把 condition 队列全部唤醒，并且将 parties 值重新赋值给 count ，实现复用。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="hashtable-vs-concurrenthashmap">Hashtable vs ConcurrentHashMap<a class="hash-link" href="#hashtable-vs-concurrenthashmap" title="标题的直接链接">​</a></h2><p>相同点：都是<strong>线程安全</strong>的 Map 集合。</p><p>不同点：</p><ul><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻只有一个线程操作它。</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不用锁，就不会冲突。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrenthashmap-17-的实现">ConcurrentHashMap 1.7 的实现<a class="hash-link" href="#concurrenthashmap-17-的实现" title="标题的直接链接">​</a></h3><ul><li>数据结构：Segment(大数组) + HashEntry(小数组) + 链表，每个 Segment 对应一把锁。</li><li>并发度：Segment 大小即并发度，同一时刻最多能有多少个线程并发访问。Segment 不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了。</li><li>索引计算：<ul><li>大数组长度是 2^m，key 在大数组内的索引是 key 的<strong>二次 hash 值</strong>的<strong>高 m 位</strong></li><li>小数组长度是 2^n，key 在小数组内的索引是 key 的<strong>二次 hash 值</strong>的<strong>低 n 位</strong></li></ul></li><li>扩容：每个小数组扩容相对独立，小数组在==超过==扩容因子 0.75 时会触发扩容，每次==扩容翻倍==</li><li>Segment<!-- -->[0]<!-- -->原型：首次创建其他小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li><li>饿汉式初始化</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrenthashmap-18-的实现">ConcurrentHashMap 1.8 的实现<a class="hash-link" href="#concurrenthashmap-18-的实现" title="标题的直接链接">​</a></h3><ul><li><p>数据结构： Node 数组 + 链表或红黑树，数组的每个头结点作为锁，如果多个线程访问的头结点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 synchronized，进一步提升性能。</p></li><li><p>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容。</p></li><li><p>扩容条件：Node 数组满 3/4 时就会扩容（7 是超过）。</p></li><li><p>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头结点替换为 ForwardingNode</p></li><li><p>扩容时并发 get</p><ul><li>根据是否为 ForwardingNode 来决定是在新数组找还是旧数组找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），主要是怕节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li><p>扩容时并发 put</p><ul><li>如果 put 的线程与扩容线程的链表是同一个，put 线程会阻塞，扩容完才能 put</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经完成，即头节点是 ForwardingNode，则可以协助扩容（每个线程可以处理 16 个链表的迁移），扩容完才能 put</li></ul></li><li><p>懒惰初始化，第一次 put 元素时才会初始化</p></li><li><p>capacity 代表预估的元素个数，capacity / factory 来计算出初始数组大小，需要贴近 2 ^ n。例如 capacity = 16，初始化后会等于 32。</p></li><li><p>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3/4。</p></li><li><p>超过树化阈值的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocal-的理解">ThreadLocal 的理解<a class="hash-link" href="#threadlocal-的理解" title="标题的直接链接">​</a></h2><p><strong>作用</strong>：<strong>实现资源对象线程间隔离，资线程内共享。</strong></p><ol><li>ThreadLocal 可以实现 资源对象 的线程隔离，让每个线程各用各的 资源对象，避免争用引发线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ol><p><strong>原理</strong>：<strong>每个线程内都有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象。</strong></p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p><strong>特点:</strong></p><ul><li>==hash 值==： hash 值统一分配，nextHashCoded 是 AtomicInteger 对象，从魔数 0x61c88647(1640531527)自增。</li><li>==容量和扩容==：初始容量 16，扩容因子 2/3，扩容容量翻倍。</li><li>key 索引冲突后用<strong>开放寻址法</strong>解决冲突，冲突后会找下一个空闲位置</li></ul><p><strong>为什么 ThreadLocalMap 的 key 设计成弱引用？</strong></p><ul><li><p>线程可能长时间运行，如果 key 不再使用，需要在内存不足时释放其占用的内存。</p></li><li><p>但是 GC 只是让 key 的内存释放，后续还要根据可以是否为 null 来释放值的内存。</p></li></ul><p><strong>内存释放时机</strong></p><ul><li><p>被动 GC 释放 key</p><ul><li>让 key 的内存释放，关联的 value 不会释放</li></ul></li><li><p>懒惰被动释放 value</p><ul><li>get key 发现 null key，把自己的 key 放进去，把 value 清空。</li><li>set key 时，会使用==启发式扫描==，清除临近的 null key，启发次数与元素个数，是否发现 null key 有关。</li></ul></li><li><p>主动 remove 释放 key（推荐）</p><ul><li>会同时释放 key 和 value，临近的 null key 的 value 也会清除</li><li>推荐使用，因为一般我们使用 ThreadLocal 都是定义的静态变量（强引用），无法被动的靠 GC 回收。</li></ul></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yntx-it/yntx-black-iron-tutorial-fronted/tree/master/shared/docs/interview/interview-concurrency.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-collection"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">集合篇</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/yntx-black-iron-tutorial-fronted/docs/interview/interview-jvm"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">JVM 篇</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#java-线程的状态" class="table-of-contents__link toc-highlight">Java 线程的状态</a></li><li><a href="#线程池" class="table-of-contents__link toc-highlight">线程池</a></li><li><a href="#wait和-sleep的区别" class="table-of-contents__link toc-highlight">wait()和 sleep()的区别</a></li><li><a href="#生产者和消费者模式假死现象" class="table-of-contents__link toc-highlight">生产者和消费者模式假死现象</a></li><li><a href="#死锁" class="table-of-contents__link toc-highlight">死锁</a></li><li><a href="#synchronized" class="table-of-contents__link toc-highlight">synchronized</a></li><li><a href="#lock-和-synchronized-的区别" class="table-of-contents__link toc-highlight">Lock 和 synchronized 的区别</a></li><li><a href="#aqs-原理" class="table-of-contents__link toc-highlight">AQS 原理</a></li><li><a href="#reentrantlock-加锁解锁流程" class="table-of-contents__link toc-highlight">ReentrantLock 加锁、解锁流程</a></li><li><a href="#volatile" class="table-of-contents__link toc-highlight">volatile</a></li><li><a href="#cas" class="table-of-contents__link toc-highlight">CAS</a></li><li><a href="#悲观锁-vs-乐观锁" class="table-of-contents__link toc-highlight">悲观锁 vs 乐观锁</a></li><li><a href="#semaphore" class="table-of-contents__link toc-highlight">Semaphore</a></li><li><a href="#countdownlatch-vs-cyclicbarrier" class="table-of-contents__link toc-highlight">CountDownLatch vs CyclicBarrier</a></li><li><a href="#hashtable-vs-concurrenthashmap" class="table-of-contents__link toc-highlight">Hashtable vs ConcurrentHashMap</a><ul><li><a href="#concurrenthashmap-17-的实现" class="table-of-contents__link toc-highlight">ConcurrentHashMap 1.7 的实现</a></li><li><a href="#concurrenthashmap-18-的实现" class="table-of-contents__link toc-highlight">ConcurrentHashMap 1.8 的实现</a></li></ul></li><li><a href="#threadlocal-的理解" class="table-of-contents__link toc-highlight">ThreadLocal 的理解</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/yntx-black-iron-tutorial-fronted/docs/java">Java教程</a></li><li class="footer__item"><a class="footer__link-item" href="/yntx-black-iron-tutorial-fronted/docs/interview">面试宝典</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/yntx-black-iron-tutorial-fronted/blog">本站博客</a></li><li class="footer__item"><a href="https://github.com/yntx-it" target="_blank" rel="noopener noreferrer" class="footer__link-item">与你同行GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://gitee.com/yntx-org" target="_blank" rel="noopener noreferrer" class="footer__link-item">与你同行Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 与你同行技术, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/yntx-black-iron-tutorial-fronted/assets/js/runtime~main.5ce9c5ac.js"></script>
<script src="/yntx-black-iron-tutorial-fronted/assets/js/main.ee7b2638.js"></script>
</body>
</html>